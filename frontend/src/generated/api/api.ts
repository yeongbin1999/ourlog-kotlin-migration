/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * API ÏÑúÎ≤Ñ
 * ÌåÄ12 2Ï∞® ÌîÑÎ°úÏ†ùÌä∏ API ÏÑúÎ≤Ñ Î¨∏ÏÑúÏûÖÎãàÎã§.
 * OpenAPI spec version: beta
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  CommentRequestDto,
  CommentUpdateRequestDto,
  DiaryUpdateRequestDto,
  DiaryWriteRequestDto,
  EmotionGraphResponse,
  FollowUserResponse,
  GenreGraphResponse,
  GetEmotionGraphParams,
  GetGenreGraphParams,
  GetLikeCountParams,
  GetMyDiariesParams,
  GetOttGraphParams,
  GetTypeGraphParams,
  LikeCountResponse,
  LikeResponse,
  LoginRequest,
  MonthlyDiaryCount,
  OAuthCallbackRequest,
  OttGraphResponse,
  ReportRequest,
  RsDataCommentResponseDto,
  RsDataContentResponseDto,
  RsDataDiaryDetailDto,
  RsDataDiaryResponseDto,
  RsDataListCommentResponseDto,
  RsDataListContentSearchResultDto,
  RsDataListTagResponse,
  RsDataLoginResponse,
  RsDataMyProfileResponse,
  RsDataObject,
  RsDataPageDiaryResponseDto,
  RsDataPageResponseUserProfileResponse,
  RsDataUserProfileResponse,
  RsDataVoid,
  SearchContentsParams,
  SearchUsersParams,
  SignupRequest,
  StatisticsCardDto,
  TimelineResponse,
  TypeCountDto,
  TypeGraphResponse,
} from "../model";

import { customInstance } from "../../lib/api-client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Ï°∞Ìöå
 */
export const getDiary = (
  diaryId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataDiaryDetailDto>(
    { url: `/api/v1/diaries/${diaryId}`, method: "GET", signal },
    options,
  );
};

export const getGetDiaryQueryKey = (diaryId?: number) => {
  return [`/api/v1/diaries/${diaryId}`] as const;
};

export const getGetDiaryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDiary>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDiaryQueryKey(diaryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiary>>> = ({
    signal,
  }) => getDiary(diaryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!diaryId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDiary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDiaryInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDiary>>
>;
export type GetDiaryInfiniteQueryError = unknown;

export function useGetDiaryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>,
  TError = unknown,
>(
  diaryId: number,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDiary>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDiaryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDiary>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDiaryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDiary>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Ï°∞Ìöå
 */

export function useGetDiaryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDiary>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDiary>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDiaryInfiniteQueryOptions(diaryId, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDiaryQueryOptions = <
  TData = Awaited<ReturnType<typeof getDiary>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDiaryQueryKey(diaryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiary>>> = ({
    signal,
  }) => getDiary(diaryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!diaryId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetDiaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDiary>>
>;
export type GetDiaryQueryError = unknown;

export function useGetDiary<
  TData = Awaited<ReturnType<typeof getDiary>>,
  TError = unknown,
>(
  diaryId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDiary<
  TData = Awaited<ReturnType<typeof getDiary>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDiary>>,
          TError,
          Awaited<ReturnType<typeof getDiary>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDiary<
  TData = Awaited<ReturnType<typeof getDiary>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Ï°∞Ìöå
 */

export function useGetDiary<
  TData = Awaited<ReturnType<typeof getDiary>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDiary>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDiaryQueryOptions(diaryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏàòÏ†ï
 */
export const updateDiary = (
  diaryId: number,
  diaryUpdateRequestDto: DiaryUpdateRequestDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RsDataDiaryResponseDto>(
    {
      url: `/api/v1/diaries/${diaryId}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: diaryUpdateRequestDto,
    },
    options,
  );
};

export const getUpdateDiaryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDiary>>,
    TError,
    { diaryId: number; data: DiaryUpdateRequestDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDiary>>,
  TError,
  { diaryId: number; data: DiaryUpdateRequestDto },
  TContext
> => {
  const mutationKey = ["updateDiary"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDiary>>,
    { diaryId: number; data: DiaryUpdateRequestDto }
  > = (props) => {
    const { diaryId, data } = props ?? {};

    return updateDiary(diaryId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDiaryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDiary>>
>;
export type UpdateDiaryMutationBody = DiaryUpdateRequestDto;
export type UpdateDiaryMutationError = unknown;

/**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏàòÏ†ï
 */
export const useUpdateDiary = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDiary>>,
      TError,
      { diaryId: number; data: DiaryUpdateRequestDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateDiary>>,
  TError,
  { diaryId: number; data: DiaryUpdateRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateDiaryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏÇ≠Ï†ú
 */
export const deleteDiary = (
  diaryId: number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RsDataVoid>(
    { url: `/api/v1/diaries/${diaryId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteDiaryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDiary>>,
    TError,
    { diaryId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDiary>>,
  TError,
  { diaryId: number },
  TContext
> => {
  const mutationKey = ["deleteDiary"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDiary>>,
    { diaryId: number }
  > = (props) => {
    const { diaryId } = props ?? {};

    return deleteDiary(diaryId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDiaryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDiary>>
>;

export type DeleteDiaryMutationError = unknown;

/**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ ÏÇ≠Ï†ú
 */
export const useDeleteDiary = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteDiary>>,
      TError,
      { diaryId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteDiary>>,
  TError,
  { diaryId: number },
  TContext
> => {
  const mutationOptions = getDeleteDiaryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary ÎåìÍ∏Ä ÏàòÏ†ï
 */
export const updateComment = (
  commentUpdateRequestDto: CommentUpdateRequestDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RsDataVoid>(
    {
      url: `/api/v1/comments`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: commentUpdateRequestDto,
    },
    options,
  );
};

export const getUpdateCommentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateComment>>,
    TError,
    { data: CommentUpdateRequestDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateComment>>,
  TError,
  { data: CommentUpdateRequestDto },
  TContext
> => {
  const mutationKey = ["updateComment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateComment>>,
    { data: CommentUpdateRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateComment(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateComment>>
>;
export type UpdateCommentMutationBody = CommentUpdateRequestDto;
export type UpdateCommentMutationError = unknown;

/**
 * @summary ÎåìÍ∏Ä ÏàòÏ†ï
 */
export const useUpdateComment = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateComment>>,
      TError,
      { data: CommentUpdateRequestDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateComment>>,
  TError,
  { data: CommentUpdateRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary ÎåìÍ∏Ä Îì±Î°ù
 */
export const writeComment = (
  commentRequestDto: CommentRequestDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataCommentResponseDto>(
    {
      url: `/api/v1/comments`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: commentRequestDto,
      signal,
    },
    options,
  );
};

export const getWriteCommentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof writeComment>>,
    TError,
    { data: CommentRequestDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof writeComment>>,
  TError,
  { data: CommentRequestDto },
  TContext
> => {
  const mutationKey = ["writeComment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof writeComment>>,
    { data: CommentRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return writeComment(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WriteCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof writeComment>>
>;
export type WriteCommentMutationBody = CommentRequestDto;
export type WriteCommentMutationError = unknown;

/**
 * @summary ÎåìÍ∏Ä Îì±Î°ù
 */
export const useWriteComment = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof writeComment>>,
      TError,
      { data: CommentRequestDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof writeComment>>,
  TError,
  { data: CommentRequestDto },
  TContext
> => {
  const mutationOptions = getWriteCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const reportUser = (
  reportRequest: ReportRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataObject>(
    {
      url: `/api/v1/reports`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: reportRequest,
      signal,
    },
    options,
  );
};

export const getReportUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportUser>>,
    TError,
    { data: ReportRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportUser>>,
  TError,
  { data: ReportRequest },
  TContext
> => {
  const mutationKey = ["reportUser"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportUser>>,
    { data: ReportRequest }
  > = (props) => {
    const { data } = props ?? {};

    return reportUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportUser>>
>;
export type ReportUserMutationBody = ReportRequest;
export type ReportUserMutationError = unknown;

export const useReportUser = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reportUser>>,
      TError,
      { data: ReportRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reportUser>>,
  TError,
  { data: ReportRequest },
  TContext
> => {
  const mutationOptions = getReportUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const like = (
  diaryId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LikeResponse>(
    { url: `/api/v1/likes/${diaryId}`, method: "POST", signal },
    options,
  );
};

export const getLikeMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof like>>,
    TError,
    { diaryId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof like>>,
  TError,
  { diaryId: number },
  TContext
> => {
  const mutationKey = ["like"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof like>>,
    { diaryId: number }
  > = (props) => {
    const { diaryId } = props ?? {};

    return like(diaryId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeMutationResult = NonNullable<Awaited<ReturnType<typeof like>>>;

export type LikeMutationError = unknown;

/**
 * @summary Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const useLike = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof like>>,
      TError,
      { diaryId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof like>>,
  TError,
  { diaryId: number },
  TContext
> => {
  const mutationOptions = getLikeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const unlike = (
  diaryId: number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<LikeResponse>(
    { url: `/api/v1/likes/${diaryId}`, method: "DELETE" },
    options,
  );
};

export const getUnlikeMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unlike>>,
    TError,
    { diaryId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unlike>>,
  TError,
  { diaryId: number },
  TContext
> => {
  const mutationKey = ["unlike"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unlike>>,
    { diaryId: number }
  > = (props) => {
    const { diaryId } = props ?? {};

    return unlike(diaryId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnlikeMutationResult = NonNullable<
  Awaited<ReturnType<typeof unlike>>
>;

export type UnlikeMutationError = unknown;

/**
 * @summary Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const useUnlike = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unlike>>,
      TError,
      { diaryId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unlike>>,
  TError,
  { diaryId: number },
  TContext
> => {
  const mutationOptions = getUnlikeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Ïú†Ï†Ä ÌåîÎ°úÏö∞
 */
export const followUser = (
  followeeId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string>(
    { url: `/api/v1/follows/${followeeId}`, method: "POST", signal },
    options,
  );
};

export const getFollowUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof followUser>>,
    TError,
    { followeeId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof followUser>>,
  TError,
  { followeeId: number },
  TContext
> => {
  const mutationKey = ["followUser"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof followUser>>,
    { followeeId: number }
  > = (props) => {
    const { followeeId } = props ?? {};

    return followUser(followeeId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FollowUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof followUser>>
>;

export type FollowUserMutationError = unknown;

/**
 * @summary Ïú†Ï†Ä ÌåîÎ°úÏö∞
 */
export const useFollowUser = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof followUser>>,
      TError,
      { followeeId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof followUser>>,
  TError,
  { followeeId: number },
  TContext
> => {
  const mutationOptions = getFollowUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ ÏàòÎùΩ
 */
export const acceptFollow = (
  followId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string>(
    { url: `/api/v1/follows/${followId}/accept`, method: "POST", signal },
    options,
  );
};

export const getAcceptFollowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptFollow>>,
    TError,
    { followId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof acceptFollow>>,
  TError,
  { followId: number },
  TContext
> => {
  const mutationKey = ["acceptFollow"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof acceptFollow>>,
    { followId: number }
  > = (props) => {
    const { followId } = props ?? {};

    return acceptFollow(followId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AcceptFollowMutationResult = NonNullable<
  Awaited<ReturnType<typeof acceptFollow>>
>;

export type AcceptFollowMutationError = unknown;

/**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ ÏàòÎùΩ
 */
export const useAcceptFollow = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof acceptFollow>>,
      TError,
      { followId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof acceptFollow>>,
  TError,
  { followId: number },
  TContext
> => {
  const mutationOptions = getAcceptFollowMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Í∞êÏÉÅÏùºÍ∏∞Î•º ÏûëÏÑ±Ìï©ÎãàÎã§.
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Îì±Î°ù
 */
export const writeDiary = (
  diaryWriteRequestDto: DiaryWriteRequestDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataDiaryResponseDto>(
    {
      url: `/api/v1/diaries`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: diaryWriteRequestDto,
      signal,
    },
    options,
  );
};

export const getWriteDiaryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof writeDiary>>,
    TError,
    { data: DiaryWriteRequestDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof writeDiary>>,
  TError,
  { data: DiaryWriteRequestDto },
  TContext
> => {
  const mutationKey = ["writeDiary"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof writeDiary>>,
    { data: DiaryWriteRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return writeDiary(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WriteDiaryMutationResult = NonNullable<
  Awaited<ReturnType<typeof writeDiary>>
>;
export type WriteDiaryMutationBody = DiaryWriteRequestDto;
export type WriteDiaryMutationError = unknown;

/**
 * @summary Í∞êÏÉÅÏùºÍ∏∞ Îì±Î°ù
 */
export const useWriteDiary = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof writeDiary>>,
      TError,
      { data: DiaryWriteRequestDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof writeDiary>>,
  TError,
  { data: DiaryWriteRequestDto },
  TContext
> => {
  const mutationOptions = getWriteDiaryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const signup = (
  signupRequest: SignupRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataObject>(
    {
      url: `/api/v1/auth/signup`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: signupRequest,
      signal,
    },
    options,
  );
};

export const getSignupMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signup>>,
    TError,
    { data: SignupRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signup>>,
  TError,
  { data: SignupRequest },
  TContext
> => {
  const mutationKey = ["signup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signup>>,
    { data: SignupRequest }
  > = (props) => {
    const { data } = props ?? {};

    return signup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof signup>>
>;
export type SignupMutationBody = SignupRequest;
export type SignupMutationError = unknown;

export const useSignup = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signup>>,
      TError,
      { data: SignupRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof signup>>,
  TError,
  { data: SignupRequest },
  TContext
> => {
  const mutationOptions = getSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const reissue = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataLoginResponse>(
    { url: `/api/v1/auth/reissue`, method: "POST", signal },
    options,
  );
};

export const getReissueMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reissue>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reissue>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["reissue"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reissue>>,
    void
  > = () => {
    return reissue(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReissueMutationResult = NonNullable<
  Awaited<ReturnType<typeof reissue>>
>;

export type ReissueMutationError = unknown;

export const useReissue = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reissue>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reissue>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getReissueMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const oauthCallback = (
  provider: string,
  oAuthCallbackRequest: OAuthCallbackRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataLoginResponse>(
    {
      url: `/api/v1/auth/oauth/callback/${provider}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: oAuthCallbackRequest,
      signal,
    },
    options,
  );
};

export const getOauthCallbackMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthCallback>>,
    TError,
    { provider: string; data: OAuthCallbackRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthCallback>>,
  TError,
  { provider: string; data: OAuthCallbackRequest },
  TContext
> => {
  const mutationKey = ["oauthCallback"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthCallback>>,
    { provider: string; data: OAuthCallbackRequest }
  > = (props) => {
    const { provider, data } = props ?? {};

    return oauthCallback(provider, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthCallbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthCallback>>
>;
export type OauthCallbackMutationBody = OAuthCallbackRequest;
export type OauthCallbackMutationError = unknown;

export const useOauthCallback = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthCallback>>,
      TError,
      { provider: string; data: OAuthCallbackRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof oauthCallback>>,
  TError,
  { provider: string; data: OAuthCallbackRequest },
  TContext
> => {
  const mutationOptions = getOauthCallbackMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const logout = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataObject>(
    { url: `/api/v1/auth/logout`, method: "POST", signal },
    options,
  );
};

export const getLogoutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["logout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>;

export type LogoutMutationError = unknown;

export const useLogout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logout>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const login = (
  loginRequest: LoginRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataLoginResponse>(
    {
      url: `/api/v1/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginRequest,
      signal,
    },
    options,
  );
};

export const getLoginMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationKey = ["login"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: LoginRequest }
  > = (props) => {
    const { data } = props ?? {};

    return login(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = LoginRequest;
export type LoginMutationError = unknown;

export const useLogin = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { data: LoginRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getUserProfile = (
  userId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataUserProfileResponse>(
    { url: `/api/v1/users/${userId}`, method: "GET", signal },
    options,
  );
};

export const getGetUserProfileQueryKey = (userId?: number) => {
  return [`/api/v1/users/${userId}`] as const;
};

export const getGetUserProfileInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserProfile>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserProfileQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({
    signal,
  }) => getUserProfile(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUserProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserProfileInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserProfile>>
>;
export type GetUserProfileInfiniteQueryError = unknown;

export function useGetUserProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>,
  TError = unknown,
>(
  userId: number,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserProfile>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserProfile>>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserProfile>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserProfileInfiniteQueryOptions(userId, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserProfile>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserProfileQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({
    signal,
  }) => getUserProfile(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserProfile>>
>;
export type GetUserProfileQueryError = unknown;

export function useGetUserProfile<
  TData = Awaited<ReturnType<typeof getUserProfile>>,
  TError = unknown,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserProfile<
  TData = Awaited<ReturnType<typeof getUserProfile>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserProfile>>,
          TError,
          Awaited<ReturnType<typeof getUserProfile>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserProfile<
  TData = Awaited<ReturnType<typeof getUserProfile>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserProfile<
  TData = Awaited<ReturnType<typeof getUserProfile>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserProfileQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchUsers = (
  params: SearchUsersParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataPageResponseUserProfileResponse>(
    { url: `/api/v1/users/search`, method: "GET", params, signal },
    options,
  );
};

export const getSearchUsersQueryKey = (params?: SearchUsersParams) => {
  return [`/api/v1/users/search`, ...(params ? [params] : [])] as const;
};

export const getSearchUsersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchUsers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsers>>> = ({
    signal,
  }) => searchUsers(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchUsersInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchUsers>>
>;
export type SearchUsersInfiniteQueryError = unknown;

export function useSearchUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchUsers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchUsers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchUsers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSearchUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchUsers>>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchUsers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchUsersInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsers>>> = ({
    signal,
  }) => searchUsers(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchUsers>>
>;
export type SearchUsersQueryError = unknown;

export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = unknown,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchUsersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMe = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataMyProfileResponse>(
    { url: `/api/v1/users/me`, method: "GET", signal },
    options,
  );
};

export const getGetMeQueryKey = () => {
  return [`/api/v1/users/me`] as const;
};

export const getGetMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({
    signal,
  }) => getMe(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMeInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMe>>
>;
export type GetMeInfiniteQueryError = unknown;

export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({
    signal,
  }) => getMe(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>;
export type GetMeQueryError = unknown;

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í≥µÍ∞úÎêú ÏùºÍ∏∞ Ïπ¥Îìú Ï°∞Ìöå
 * @summary ÌÉÄÏûÑÎùºÏù∏ Ï°∞Ìöå
 */
export const getPublicTimeline = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TimelineResponse[]>(
    { url: `/api/v1/timeline`, method: "GET", signal },
    options,
  );
};

export const getGetPublicTimelineQueryKey = () => {
  return [`/api/v1/timeline`] as const;
};

export const getGetPublicTimelineInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getPublicTimeline>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicTimelineQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPublicTimeline>>
  > = ({ signal }) => getPublicTimeline(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPublicTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPublicTimelineInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPublicTimeline>>
>;
export type GetPublicTimelineInfiniteQueryError = unknown;

export function useGetPublicTimelineInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublicTimelineInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublicTimelineInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÌÉÄÏûÑÎùºÏù∏ Ï°∞Ìöå
 */

export function useGetPublicTimelineInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPublicTimeline>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPublicTimelineInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPublicTimelineQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicTimeline>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPublicTimeline>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicTimelineQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPublicTimeline>>
  > = ({ signal }) => getPublicTimeline(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPublicTimelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPublicTimeline>>
>;
export type GetPublicTimelineQueryError = unknown;

export function useGetPublicTimeline<
  TData = Awaited<ReturnType<typeof getPublicTimeline>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublicTimeline<
  TData = Awaited<ReturnType<typeof getPublicTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicTimeline>>,
          TError,
          Awaited<ReturnType<typeof getPublicTimeline>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublicTimeline<
  TData = Awaited<ReturnType<typeof getPublicTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÌÉÄÏûÑÎùºÏù∏ Ï°∞Ìöå
 */

export function useGetPublicTimeline<
  TData = Awaited<ReturnType<typeof getPublicTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublicTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPublicTimelineQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Îì±Î°ùÎêú Î™®Îì† ÌÉúÍ∑∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Ï°∞Ìöå
 */
export const getAllTags = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataListTagResponse>(
    { url: `/api/v1/tags`, method: "GET", signal },
    options,
  );
};

export const getGetAllTagsQueryKey = () => {
  return [`/api/v1/tags`] as const;
};

export const getGetAllTagsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getAllTags>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllTagsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTags>>> = ({
    signal,
  }) => getAllTags(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAllTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllTagsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTags>>
>;
export type GetAllTagsInfiniteQueryError = unknown;

export function useGetAllTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAllTags>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAllTags>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAllTags>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Ï°∞Ìöå
 */

export function useGetAllTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllTags>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAllTags>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllTagsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllTagsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllTags>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllTagsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTags>>> = ({
    signal,
  }) => getAllTags(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllTagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTags>>
>;
export type GetAllTagsQueryError = unknown;

export function useGetAllTags<
  TData = Awaited<ReturnType<typeof getAllTags>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTags<
  TData = Awaited<ReturnType<typeof getAllTags>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTags<
  TData = Awaited<ReturnType<typeof getAllTags>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Ï°∞Ìöå
 */

export function useGetAllTags<
  TData = Awaited<ReturnType<typeof getAllTags>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllTagsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏΩòÌÖêÏ∏† ÌÉÄÏûÖÏóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏΩòÌÖêÏ∏† ÌÉÄÏûÖ Í∑∏ÎûòÌîÑ
 */
export const getTypeGraph = (
  params: GetTypeGraphParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TypeGraphResponse>(
    { url: `/api/v1/statistics/type-graph`, method: "GET", params, signal },
    options,
  );
};

export const getGetTypeGraphQueryKey = (params?: GetTypeGraphParams) => {
  return [
    `/api/v1/statistics/type-graph`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetTypeGraphInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTypeGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTypeGraph>>> = ({
    signal,
  }) => getTypeGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTypeGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTypeGraphInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTypeGraph>>
>;
export type GetTypeGraphInfiniteQueryError = unknown;

export function useGetTypeGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏΩòÌÖêÏ∏† ÌÉÄÏûÖ Í∑∏ÎûòÌîÑ
 */

export function useGetTypeGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeGraph>>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTypeGraphInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTypeGraphQueryOptions = <
  TData = Awaited<ReturnType<typeof getTypeGraph>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTypeGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTypeGraph>>> = ({
    signal,
  }) => getTypeGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTypeGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTypeGraphQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTypeGraph>>
>;
export type GetTypeGraphQueryError = unknown;

export function useGetTypeGraph<
  TData = Awaited<ReturnType<typeof getTypeGraph>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeGraph<
  TData = Awaited<ReturnType<typeof getTypeGraph>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeGraph>>,
          TError,
          Awaited<ReturnType<typeof getTypeGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeGraph<
  TData = Awaited<ReturnType<typeof getTypeGraph>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏΩòÌÖêÏ∏† ÌÉÄÏûÖ Í∑∏ÎûòÌîÑ
 */

export function useGetTypeGraph<
  TData = Awaited<ReturnType<typeof getTypeGraph>>,
  TError = unknown,
>(
  params: GetTypeGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTypeGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTypeGraphQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÌöåÏõêÏùò ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨Î•º Ï°∞ÌöåÌï©ÎãàÎã§
 * @summary ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨
 */
export const getTypeDistribution = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TypeCountDto[]>(
    { url: `/api/v1/statistics/type-distribution`, method: "GET", signal },
    options,
  );
};

export const getGetTypeDistributionQueryKey = () => {
  return [`/api/v1/statistics/type-distribution`] as const;
};

export const getGetTypeDistributionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getTypeDistribution>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTypeDistributionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTypeDistribution>>
  > = ({ signal }) => getTypeDistribution(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTypeDistribution>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTypeDistributionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTypeDistribution>>
>;
export type GetTypeDistributionInfiniteQueryError = unknown;

export function useGetTypeDistributionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeDistributionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeDistributionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨
 */

export function useGetTypeDistributionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTypeDistribution>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTypeDistributionInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTypeDistributionQueryOptions = <
  TData = Awaited<ReturnType<typeof getTypeDistribution>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTypeDistribution>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTypeDistributionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTypeDistribution>>
  > = ({ signal }) => getTypeDistribution(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTypeDistribution>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTypeDistributionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTypeDistribution>>
>;
export type GetTypeDistributionQueryError = unknown;

export function useGetTypeDistribution<
  TData = Awaited<ReturnType<typeof getTypeDistribution>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeDistribution<
  TData = Awaited<ReturnType<typeof getTypeDistribution>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getTypeDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTypeDistribution<
  TData = Awaited<ReturnType<typeof getTypeDistribution>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏΩòÌÖåÏ∏† ÌÉÄÏûÖ Î∂ÑÌè¨
 */

export function useGetTypeDistribution<
  TData = Awaited<ReturnType<typeof getTypeDistribution>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTypeDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTypeDistributionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * OTTÏóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary OTT Í∑∏ÎûòÌîÑ
 */
export const getOttGraph = (
  params: GetOttGraphParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<OttGraphResponse>(
    { url: `/api/v1/statistics/ott-graph`, method: "GET", params, signal },
    options,
  );
};

export const getGetOttGraphQueryKey = (params?: GetOttGraphParams) => {
  return [`/api/v1/statistics/ott-graph`, ...(params ? [params] : [])] as const;
};

export const getGetOttGraphInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getOttGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOttGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOttGraph>>> = ({
    signal,
  }) => getOttGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getOttGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOttGraphInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOttGraph>>
>;
export type GetOttGraphInfiniteQueryError = unknown;

export function useGetOttGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getOttGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOttGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getOttGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOttGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getOttGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary OTT Í∑∏ÎûòÌîÑ
 */

export function useGetOttGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOttGraph>>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getOttGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetOttGraphInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetOttGraphQueryOptions = <
  TData = Awaited<ReturnType<typeof getOttGraph>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOttGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOttGraph>>> = ({
    signal,
  }) => getOttGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getOttGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOttGraphQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOttGraph>>
>;
export type GetOttGraphQueryError = unknown;

export function useGetOttGraph<
  TData = Awaited<ReturnType<typeof getOttGraph>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOttGraph<
  TData = Awaited<ReturnType<typeof getOttGraph>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOttGraph>>,
          TError,
          Awaited<ReturnType<typeof getOttGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOttGraph<
  TData = Awaited<ReturnType<typeof getOttGraph>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary OTT Í∑∏ÎûòÌîÑ
 */

export function useGetOttGraph<
  TData = Awaited<ReturnType<typeof getOttGraph>>,
  TError = unknown,
>(
  params: GetOttGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOttGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetOttGraphQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÌöåÏõêÏùò ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ ÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§
 * @summary ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ Ïàò
 */
export const getLast6MonthsDiaryCounts = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MonthlyDiaryCount[]>(
    { url: `/api/v1/statistics/monthly-diary-graph`, method: "GET", signal },
    options,
  );
};

export const getGetLast6MonthsDiaryCountsQueryKey = () => {
  return [`/api/v1/statistics/monthly-diary-graph`] as const;
};

export const getGetLast6MonthsDiaryCountsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLast6MonthsDiaryCountsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
  > = ({ signal }) => getLast6MonthsDiaryCounts(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLast6MonthsDiaryCountsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
>;
export type GetLast6MonthsDiaryCountsInfiniteQueryError = unknown;

export function useGetLast6MonthsDiaryCountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLast6MonthsDiaryCountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLast6MonthsDiaryCountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ Ïàò
 */

export function useGetLast6MonthsDiaryCountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetLast6MonthsDiaryCountsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetLast6MonthsDiaryCountsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLast6MonthsDiaryCountsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
  > = ({ signal }) => getLast6MonthsDiaryCounts(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLast6MonthsDiaryCountsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
>;
export type GetLast6MonthsDiaryCountsQueryError = unknown;

export function useGetLast6MonthsDiaryCounts<
  TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLast6MonthsDiaryCounts<
  TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
          TError,
          Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLast6MonthsDiaryCounts<
  TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏµúÍ∑º 6Í∞úÏõî Ïõî Î≥Ñ Í∞êÏÉÅ Ïàò
 */

export function useGetLast6MonthsDiaryCounts<
  TData = Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLast6MonthsDiaryCounts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLast6MonthsDiaryCountsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïû•Î•¥Ïóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïû•Î•¥ Í∑∏ÎûòÌîÑ
 */
export const getGenreGraph = (
  params: GetGenreGraphParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GenreGraphResponse>(
    { url: `/api/v1/statistics/genre-graph`, method: "GET", params, signal },
    options,
  );
};

export const getGetGenreGraphQueryKey = (params?: GetGenreGraphParams) => {
  return [
    `/api/v1/statistics/genre-graph`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetGenreGraphInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGenreGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenreGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenreGraph>>> = ({
    signal,
  }) => getGenreGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getGenreGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGenreGraphInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenreGraph>>
>;
export type GetGenreGraphInfiniteQueryError = unknown;

export function useGetGenreGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGenreGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenreGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGenreGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenreGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGenreGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïû•Î•¥ Í∑∏ÎûòÌîÑ
 */

export function useGetGenreGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGenreGraph>>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGenreGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGenreGraphInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGenreGraphQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenreGraph>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenreGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenreGraph>>> = ({
    signal,
  }) => getGenreGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGenreGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGenreGraphQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenreGraph>>
>;
export type GetGenreGraphQueryError = unknown;

export function useGetGenreGraph<
  TData = Awaited<ReturnType<typeof getGenreGraph>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenreGraph<
  TData = Awaited<ReturnType<typeof getGenreGraph>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreGraph>>,
          TError,
          Awaited<ReturnType<typeof getGenreGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenreGraph<
  TData = Awaited<ReturnType<typeof getGenreGraph>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïû•Î•¥ Í∑∏ÎûòÌîÑ
 */

export function useGetGenreGraph<
  TData = Awaited<ReturnType<typeof getGenreGraph>>,
  TError = unknown,
>(
  params: GetGenreGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreGraph>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGenreGraphQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í∞êÏ†ïÏóê ÎåÄÌïú Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í∞êÏ†ï Í∑∏ÎûòÌîÑ
 */
export const getEmotionGraph = (
  params: GetEmotionGraphParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmotionGraphResponse>(
    { url: `/api/v1/statistics/emotion-graph`, method: "GET", params, signal },
    options,
  );
};

export const getGetEmotionGraphQueryKey = (params?: GetEmotionGraphParams) => {
  return [
    `/api/v1/statistics/emotion-graph`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetEmotionGraphInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEmotionGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmotionGraph>>> = ({
    signal,
  }) => getEmotionGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getEmotionGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEmotionGraphInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEmotionGraph>>
>;
export type GetEmotionGraphInfiniteQueryError = unknown;

export function useGetEmotionGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEmotionGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEmotionGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Í∞êÏ†ï Í∑∏ÎûòÌîÑ
 */

export function useGetEmotionGraphInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getEmotionGraph>>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEmotionGraphInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetEmotionGraphQueryOptions = <
  TData = Awaited<ReturnType<typeof getEmotionGraph>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEmotionGraphQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmotionGraph>>> = ({
    signal,
  }) => getEmotionGraph(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEmotionGraph>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEmotionGraphQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEmotionGraph>>
>;
export type GetEmotionGraphQueryError = unknown;

export function useGetEmotionGraph<
  TData = Awaited<ReturnType<typeof getEmotionGraph>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEmotionGraph<
  TData = Awaited<ReturnType<typeof getEmotionGraph>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmotionGraph>>,
          TError,
          Awaited<ReturnType<typeof getEmotionGraph>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEmotionGraph<
  TData = Awaited<ReturnType<typeof getEmotionGraph>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Í∞êÏ†ï Í∑∏ÎûòÌîÑ
 */

export function useGetEmotionGraph<
  TData = Awaited<ReturnType<typeof getEmotionGraph>>,
  TError = unknown,
>(
  params: GetEmotionGraphParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEmotionGraph>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEmotionGraphQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ï¥ù Í∞êÏÉÅ Ïàò, ÌèâÍ∑† Î≥ÑÏ†ï, ÏÑ†Ìò∏ Ïû•Î•¥, Ï£ºÏöî Í∞êÏ†ïÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌÜµÍ≥Ñ Ïπ¥Îìú Ï°∞Ìöå
 */
export const getStatisticsCard = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatisticsCardDto>(
    { url: `/api/v1/statistics/card`, method: "GET", signal },
    options,
  );
};

export const getGetStatisticsCardQueryKey = () => {
  return [`/api/v1/statistics/card`] as const;
};

export const getGetStatisticsCardInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getStatisticsCard>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStatisticsCardQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStatisticsCard>>
  > = ({ signal }) => getStatisticsCard(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getStatisticsCard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStatisticsCardInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStatisticsCard>>
>;
export type GetStatisticsCardInfiniteQueryError = unknown;

export function useGetStatisticsCardInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStatisticsCardInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStatisticsCardInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÌÜµÍ≥Ñ Ïπ¥Îìú Ï°∞Ìöå
 */

export function useGetStatisticsCardInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStatisticsCard>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetStatisticsCardInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetStatisticsCardQueryOptions = <
  TData = Awaited<ReturnType<typeof getStatisticsCard>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStatisticsCard>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStatisticsCardQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStatisticsCard>>
  > = ({ signal }) => getStatisticsCard(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStatisticsCard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStatisticsCardQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStatisticsCard>>
>;
export type GetStatisticsCardQueryError = unknown;

export function useGetStatisticsCard<
  TData = Awaited<ReturnType<typeof getStatisticsCard>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStatisticsCard<
  TData = Awaited<ReturnType<typeof getStatisticsCard>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatisticsCard>>,
          TError,
          Awaited<ReturnType<typeof getStatisticsCard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStatisticsCard<
  TData = Awaited<ReturnType<typeof getStatisticsCard>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÌÜµÍ≥Ñ Ïπ¥Îìú Ï°∞Ìöå
 */

export function useGetStatisticsCard<
  TData = Awaited<ReturnType<typeof getStatisticsCard>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStatisticsCard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetStatisticsCardQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ï¢ãÏïÑÏöî Ïàò Îã®Í±¥ Ï°∞Ìöå
 */
export const getLikeCount = (
  params: GetLikeCountParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LikeCountResponse>(
    { url: `/api/v1/likes/count`, method: "GET", params, signal },
    options,
  );
};

export const getGetLikeCountQueryKey = (params?: GetLikeCountParams) => {
  return [`/api/v1/likes/count`, ...(params ? [params] : [])] as const;
};

export const getGetLikeCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLikeCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLikeCountQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLikeCount>>> = ({
    signal,
  }) => getLikeCount(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLikeCountInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLikeCount>>
>;
export type GetLikeCountInfiniteQueryError = unknown;

export function useGetLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLikeCount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLikeCount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLikeCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ï¢ãÏïÑÏöî Ïàò Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getLikeCount>>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getLikeCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLikeCountInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetLikeCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getLikeCount>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLikeCountQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLikeCount>>> = ({
    signal,
  }) => getLikeCount(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLikeCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLikeCount>>
>;
export type GetLikeCountQueryError = unknown;

export function useGetLikeCount<
  TData = Awaited<ReturnType<typeof getLikeCount>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLikeCount<
  TData = Awaited<ReturnType<typeof getLikeCount>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getLikeCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLikeCount<
  TData = Awaited<ReturnType<typeof getLikeCount>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ï¢ãÏïÑÏöî Ïàò Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetLikeCount<
  TData = Awaited<ReturnType<typeof getLikeCount>>,
  TError = unknown,
>(
  params: GetLikeCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLikeCount>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLikeCountQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏïÑÏßÅ ÏàòÎùΩÎêòÏßÄ ÏïäÏùÄ PENDING ÏÉÅÌÉúÏùò ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */
export const getSentRequests = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FollowUserResponse[]>(
    { url: `/api/v1/follows/sent-requests`, method: "GET", signal },
    options,
  );
};

export const getGetSentRequestsQueryKey = () => {
  return [`/api/v1/follows/sent-requests`] as const;
};

export const getGetSentRequestsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getSentRequests>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSentRequestsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSentRequests>>> = ({
    signal,
  }) => getSentRequests(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSentRequests>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSentRequestsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSentRequests>>
>;
export type GetSentRequestsInfiniteQueryError = unknown;

export function useGetSentRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSentRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSentRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetSentRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSentRequests>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSentRequestsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSentRequestsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSentRequests>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSentRequests>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSentRequestsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSentRequests>>> = ({
    signal,
  }) => getSentRequests(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSentRequests>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSentRequestsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSentRequests>>
>;
export type GetSentRequestsQueryError = unknown;

export function useGetSentRequests<
  TData = Awaited<ReturnType<typeof getSentRequests>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSentRequests<
  TData = Awaited<ReturnType<typeof getSentRequests>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSentRequests>>,
          TError,
          Awaited<ReturnType<typeof getSentRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSentRequests<
  TData = Awaited<ReturnType<typeof getSentRequests>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetSentRequests<
  TData = Awaited<ReturnType<typeof getSentRequests>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSentRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSentRequestsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * PENDING ÏÉÅÌÉúÏùò ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇ¥Í∞Ä Î∞õÏùÄ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */
export const getPendingRequests = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FollowUserResponse[]>(
    { url: `/api/v1/follows/requests`, method: "GET", signal },
    options,
  );
};

export const getGetPendingRequestsQueryKey = () => {
  return [`/api/v1/follows/requests`] as const;
};

export const getGetPendingRequestsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getPendingRequests>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingRequestsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPendingRequests>>
  > = ({ signal }) => getPendingRequests(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPendingRequests>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingRequestsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPendingRequests>>
>;
export type GetPendingRequestsInfiniteQueryError = unknown;

export function useGetPendingRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥Í∞Ä Î∞õÏùÄ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingRequestsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingRequests>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPendingRequestsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPendingRequestsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPendingRequests>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPendingRequests>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingRequestsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPendingRequests>>
  > = ({ signal }) => getPendingRequests(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPendingRequests>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingRequestsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPendingRequests>>
>;
export type GetPendingRequestsQueryError = unknown;

export function useGetPendingRequests<
  TData = Awaited<ReturnType<typeof getPendingRequests>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingRequests<
  TData = Awaited<ReturnType<typeof getPendingRequests>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingRequests>>,
          TError,
          Awaited<ReturnType<typeof getPendingRequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingRequests<
  TData = Awaited<ReturnType<typeof getPendingRequests>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥Í∞Ä Î∞õÏùÄ ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingRequests<
  TData = Awaited<ReturnType<typeof getPendingRequests>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingRequests>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPendingRequestsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ACCEPTED ÏÉÅÌÉúÏùò Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇ¥Í∞Ä ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */
export const getFollowings = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FollowUserResponse[]>(
    { url: `/api/v1/follows/followings`, method: "GET", signal },
    options,
  );
};

export const getGetFollowingsQueryKey = () => {
  return [`/api/v1/follows/followings`] as const;
};

export const getGetFollowingsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getFollowings>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFollowingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowings>>> = ({
    signal,
  }) => getFollowings(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFollowings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFollowingsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFollowings>>
>;
export type GetFollowingsInfiniteQueryError = unknown;

export function useGetFollowingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowings>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowings>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥Í∞Ä ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowings>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFollowingsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFollowingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getFollowings>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFollowingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowings>>> = ({
    signal,
  }) => getFollowings(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFollowings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFollowingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFollowings>>
>;
export type GetFollowingsQueryError = unknown;

export function useGetFollowings<
  TData = Awaited<ReturnType<typeof getFollowings>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowings<
  TData = Awaited<ReturnType<typeof getFollowings>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowings>>,
          TError,
          Awaited<ReturnType<typeof getFollowings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowings<
  TData = Awaited<ReturnType<typeof getFollowings>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥Í∞Ä ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowings<
  TData = Awaited<ReturnType<typeof getFollowings>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowings>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFollowingsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ACCEPTED ÏÉÅÌÉúÏùò Î™©Î°ùÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÎÇòÎ•º ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */
export const getFollowers = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FollowUserResponse[]>(
    { url: `/api/v1/follows/followers`, method: "GET", signal },
    options,
  );
};

export const getGetFollowersQueryKey = () => {
  return [`/api/v1/follows/followers`] as const;
};

export const getGetFollowersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getFollowers>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFollowersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowers>>> = ({
    signal,
  }) => getFollowers(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFollowers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFollowersInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFollowers>>
>;
export type GetFollowersInfiniteQueryError = unknown;

export function useGetFollowersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇòÎ•º ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFollowers>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFollowers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFollowersInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFollowersQueryOptions = <
  TData = Awaited<ReturnType<typeof getFollowers>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFollowersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFollowers>>> = ({
    signal,
  }) => getFollowers(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFollowers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFollowersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFollowers>>
>;
export type GetFollowersQueryError = unknown;

export function useGetFollowers<
  TData = Awaited<ReturnType<typeof getFollowers>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowers<
  TData = Awaited<ReturnType<typeof getFollowers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFollowers>>,
          TError,
          Awaited<ReturnType<typeof getFollowers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFollowers<
  TData = Awaited<ReturnType<typeof getFollowers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇòÎ•º ÌåîÎ°úÏö∞Ìïú Ïú†Ï†Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFollowers<
  TData = Awaited<ReturnType<typeof getFollowers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFollowers>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFollowersQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò Í∞êÏÉÅÏùºÍ∏∞ Î™©Î°ùÏùÑ ÌéòÏù¥Ïßï Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Îã§Ïù¥Ïñ¥Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */
export const getMyDiaries = (
  userId: number,
  params: GetMyDiariesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataPageDiaryResponseDto>(
    { url: `/api/v1/diaries/users/${userId}`, method: "GET", params, signal },
    options,
  );
};

export const getGetMyDiariesQueryKey = (
  userId?: number,
  params?: GetMyDiariesParams,
) => {
  return [
    `/api/v1/diaries/users/${userId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMyDiariesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyDiaries>>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyDiaries>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyDiariesQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyDiaries>>> = ({
    signal,
  }) => getMyDiaries(userId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyDiaries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyDiariesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyDiaries>>
>;
export type GetMyDiariesInfiniteQueryError = unknown;

export function useGetMyDiariesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyDiaries>>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyDiaries>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDiaries>>,
          TError,
          Awaited<ReturnType<typeof getMyDiaries>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyDiariesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyDiaries>>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyDiaries>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDiaries>>,
          TError,
          Awaited<ReturnType<typeof getMyDiaries>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyDiariesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyDiaries>>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyDiaries>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥ Îã§Ïù¥Ïñ¥Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetMyDiariesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyDiaries>>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyDiaries>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMyDiariesInfiniteQueryOptions(
    userId,
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyDiariesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyDiaries>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyDiaries>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyDiariesQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyDiaries>>> = ({
    signal,
  }) => getMyDiaries(userId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyDiaries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyDiariesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyDiaries>>
>;
export type GetMyDiariesQueryError = unknown;

export function useGetMyDiaries<
  TData = Awaited<ReturnType<typeof getMyDiaries>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyDiaries>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDiaries>>,
          TError,
          Awaited<ReturnType<typeof getMyDiaries>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyDiaries<
  TData = Awaited<ReturnType<typeof getMyDiaries>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyDiaries>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDiaries>>,
          TError,
          Awaited<ReturnType<typeof getMyDiaries>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyDiaries<
  TData = Awaited<ReturnType<typeof getMyDiaries>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyDiaries>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÇ¥ Îã§Ïù¥Ïñ¥Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetMyDiaries<
  TData = Awaited<ReturnType<typeof getMyDiaries>>,
  TError = unknown,
>(
  userId: number,
  params: GetMyDiariesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyDiaries>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMyDiariesQueryOptions(userId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ïª®ÌÖêÏ∏† Ï°∞Ìöå
 */
export const getContent = (
  diaryId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataContentResponseDto>(
    { url: `/api/v1/contents/${diaryId}`, method: "GET", signal },
    options,
  );
};

export const getGetContentQueryKey = (diaryId?: number) => {
  return [`/api/v1/contents/${diaryId}`] as const;
};

export const getGetContentInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetContentQueryKey(diaryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getContent>>> = ({
    signal,
  }) => getContent(diaryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!diaryId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetContentInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getContent>>
>;
export type GetContentInfiniteQueryError = unknown;

export function useGetContentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>,
  TError = unknown,
>(
  diaryId: number,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getContent>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetContentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getContent>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetContentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïª®ÌÖêÏ∏† Ï°∞Ìöå
 */

export function useGetContentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getContent>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetContentInfiniteQueryOptions(diaryId, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetContentQueryOptions = <
  TData = Awaited<ReturnType<typeof getContent>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetContentQueryKey(diaryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getContent>>> = ({
    signal,
  }) => getContent(diaryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!diaryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getContent>>
>;
export type GetContentQueryError = unknown;

export function useGetContent<
  TData = Awaited<ReturnType<typeof getContent>>,
  TError = unknown,
>(
  diaryId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetContent<
  TData = Awaited<ReturnType<typeof getContent>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContent>>,
          TError,
          Awaited<ReturnType<typeof getContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetContent<
  TData = Awaited<ReturnType<typeof getContent>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïª®ÌÖêÏ∏† Ï°∞Ìöå
 */

export function useGetContent<
  TData = Awaited<ReturnType<typeof getContent>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetContentQueryOptions(diaryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïª®ÌÖêÏ∏†Î•º Í≤ÄÏÉâÌï©ÎãàÎã§.
 * @summary Ïª®ÌÖêÏ∏† Í≤ÄÏÉâ
 */
export const searchContents = (
  params: SearchContentsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataListContentSearchResultDto>(
    { url: `/api/v1/contents/search`, method: "GET", params, signal },
    options,
  );
};

export const getSearchContentsQueryKey = (params?: SearchContentsParams) => {
  return [`/api/v1/contents/search`, ...(params ? [params] : [])] as const;
};

export const getSearchContentsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchContents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchContentsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchContents>>> = ({
    signal,
  }) => searchContents(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchContents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchContentsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchContents>>
>;
export type SearchContentsInfiniteQueryError = unknown;

export function useSearchContentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchContents>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchContentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchContents>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchContentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchContents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïª®ÌÖêÏ∏† Í≤ÄÏÉâ
 */

export function useSearchContentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchContents>>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchContents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchContentsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchContentsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchContents>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchContentsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchContents>>> = ({
    signal,
  }) => searchContents(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchContents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchContentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchContents>>
>;
export type SearchContentsQueryError = unknown;

export function useSearchContents<
  TData = Awaited<ReturnType<typeof searchContents>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchContents<
  TData = Awaited<ReturnType<typeof searchContents>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchContents>>,
          TError,
          Awaited<ReturnType<typeof searchContents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchContents<
  TData = Awaited<ReturnType<typeof searchContents>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ïª®ÌÖêÏ∏† Í≤ÄÏÉâ
 */

export function useSearchContents<
  TData = Awaited<ReturnType<typeof searchContents>>,
  TError = unknown,
>(
  params: SearchContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchContents>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchContentsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÎåìÍ∏Ä Ï°∞Ìöå
 */
export const getComments = (
  diaryId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RsDataListCommentResponseDto>(
    { url: `/api/v1/comments/${diaryId}`, method: "GET", signal },
    options,
  );
};

export const getGetCommentsQueryKey = (diaryId?: number) => {
  return [`/api/v1/comments/${diaryId}`] as const;
};

export const getGetCommentsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCommentsQueryKey(diaryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getComments>>> = ({
    signal,
  }) => getComments(diaryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!diaryId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getComments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCommentsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getComments>>
>;
export type GetCommentsInfiniteQueryError = unknown;

export function useGetCommentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>,
  TError = unknown,
>(
  diaryId: number,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getComments>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCommentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getComments>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCommentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎåìÍ∏Ä Ï°∞Ìöå
 */

export function useGetCommentsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getComments>>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCommentsInfiniteQueryOptions(diaryId, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCommentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getComments>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCommentsQueryKey(diaryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getComments>>> = ({
    signal,
  }) => getComments(diaryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!diaryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getComments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCommentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getComments>>
>;
export type GetCommentsQueryError = unknown;

export function useGetComments<
  TData = Awaited<ReturnType<typeof getComments>>,
  TError = unknown,
>(
  diaryId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetComments<
  TData = Awaited<ReturnType<typeof getComments>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetComments<
  TData = Awaited<ReturnType<typeof getComments>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎåìÍ∏Ä Ï°∞Ìöå
 */

export function useGetComments<
  TData = Awaited<ReturnType<typeof getComments>>,
  TError = unknown,
>(
  diaryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCommentsQueryOptions(diaryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ÌåîÎ°úÏö∞ Í¥ÄÍ≥Ñ ÎÅäÍ∏∞ (Ïñ∏ÌåîÎ°úÏö∞)
 */
export const unfollowUser = (
  otherUserId: number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    { url: `/api/v1/follows/${otherUserId}`, method: "DELETE" },
    options,
  );
};

export const getUnfollowUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unfollowUser>>,
    TError,
    { otherUserId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unfollowUser>>,
  TError,
  { otherUserId: number },
  TContext
> => {
  const mutationKey = ["unfollowUser"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unfollowUser>>,
    { otherUserId: number }
  > = (props) => {
    const { otherUserId } = props ?? {};

    return unfollowUser(otherUserId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnfollowUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof unfollowUser>>
>;

export type UnfollowUserMutationError = unknown;

/**
 * @summary ÌåîÎ°úÏö∞ Í¥ÄÍ≥Ñ ÎÅäÍ∏∞ (Ïñ∏ÌåîÎ°úÏö∞)
 */
export const useUnfollowUser = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unfollowUser>>,
      TError,
      { otherUserId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unfollowUser>>,
  TError,
  { otherUserId: number },
  TContext
> => {
  const mutationOptions = getUnfollowUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Í±∞Ï†à
 */
export const rejectFollow = (
  followId: number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    { url: `/api/v1/follows/${followId}/reject`, method: "DELETE" },
    options,
  );
};

export const getRejectFollowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectFollow>>,
    TError,
    { followId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectFollow>>,
  TError,
  { followId: number },
  TContext
> => {
  const mutationKey = ["rejectFollow"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rejectFollow>>,
    { followId: number }
  > = (props) => {
    const { followId } = props ?? {};

    return rejectFollow(followId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RejectFollowMutationResult = NonNullable<
  Awaited<ReturnType<typeof rejectFollow>>
>;

export type RejectFollowMutationError = unknown;

/**
 * @summary ÌåîÎ°úÏö∞ ÏöîÏ≤≠ Í±∞Ï†à
 */
export const useRejectFollow = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectFollow>>,
      TError,
      { followId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof rejectFollow>>,
  TError,
  { followId: number },
  TContext
> => {
  const mutationOptions = getRejectFollowMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export const deleteComment = (
  commentId: number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RsDataVoid>(
    { url: `/api/v1/comments/${commentId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteCommentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteComment>>,
    TError,
    { commentId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteComment>>,
  TError,
  { commentId: number },
  TContext
> => {
  const mutationKey = ["deleteComment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteComment>>,
    { commentId: number }
  > = (props) => {
    const { commentId } = props ?? {};

    return deleteComment(commentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteComment>>
>;

export type DeleteCommentMutationError = unknown;

/**
 * @summary ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export const useDeleteComment = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteComment>>,
      TError,
      { commentId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteComment>>,
  TError,
  { commentId: number },
  TContext
> => {
  const mutationOptions = getDeleteCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
